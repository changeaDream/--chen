# JavaScript

### JS中的注释

`//` 单行注释
`/* */`  多行注释


JS代码需要编写到script标签中

`alert()` 控制浏览器弹出一个警告框

`document.write()` 在计算机页面中输出一个内容（向body中输出一个内容）

`console.log()` 向控制台输出一个内容（需要打开开发者模式才能看到）

`prompt()`可以弹出一个提示框，该提示框中会带有一个文本框，用户可以在文本框中输入一段内容，该函数需要一个字符串作为参数，该字符串将会作为提示框的提示文字

​	用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容，prompt()函数的返回值是String类型

**JS代码是从上到下一行一行执行的，等上一行执行完才会执行下一行**

```
<script type="text/javascript">
alert("需要弹出的内容+需要输出的其他内容");
document.write("需要向页面输出的内容");
console.log("需要向控制台输出的内容");
</script>
```

### JS编写位置

​	在html中，js代码可以编写到标签的onclick属性中，当点击按钮时，js代码才会执行

```
<button onclick="alert('点击后')">点击前</button>
```
​	可以将js代码写在超链接的href属性中，这样当点击超链接时，会执行js代码
```
<a href="javascript:alert('点击后')">点击前</a>
```

​	虽然可以写在标签的属性中，但他们属于结构与行为耦合，不方便维护，不推荐使用

------

​	在style中，可以将js代码写在script标签中，也可以写在外部js文件中，然后通过script标签引入
​	写到外部文件中可以在不同的页面中同时引用,也可以利用到浏览器的缓存机制
​	这是推荐使用的方式

​	script标签一旦用于引入外部文件了，就不能再编写代码了，即使编写了，浏览器也会忽略
​	如果需要，则可以再创建一个新的script标签用于编写内部代码

```
<script>
alert("xxx")
</script>
<script src="./xxx.js"></script>
```

### 基本语法

js基本语法
	1.js中严格区分大小写
	2.js中每一条语句都要以分号(;)结尾(现在不用了)
		如果不写分号,浏览器会自动添加,但是会消耗一些系统资源,
		而且有些时候,浏览器会加错分号,所以再开发中,分号必须写
	3.js中会忽略多个空格和换行,所以我们可以利用空格和换行对代码进行格式化

### 字面量和变量

​	字面量,都是一些不可改变的值
​		比如:1 2 3 4 5
​	字面量都是可以直接使用的,但是我们一般都不会直接使用字面量

​	变量,变量可以用来保存字面量,而且变量的值时可以任意改变的
​		变量更加方便我们使用,所以在开发中都是通过变量区保存一个字面量,而很少直接使用字面量
​		可以通过变量对字面量进行描述

#### 声明变量

​	在js中使用var关键字来声明一个变量
​		`var a;`

#### 为变量赋值

​		`a = 123;`
​	变量的值可以改变,下面的赋值会覆盖上面的

**声明和赋值可以同时进行**
		`var a = 123;`

声明过的变量就不用再次声明了，之后可以直接进行赋值来改变变量的值

### 标识符

​	在js中所有的可以由我们自主命名的都可以称为时标识符
​		例如: 变量名 函数名 属性名都属于标识符
​	命名一个标识符时需要遵守如下的规则:
​		1.标识符中只可以含有 字母、数字、_ 、$
​		2.标识符不能以数字开头
​		3.标识符不能是es中的关键字或保留字

<img src="C:\Users\阿堆\Desktop\study\typora\img\微信图片_20210406160216.png" style="zoom: 67%;" />

​		4.标识符一般都采用驼峰命名法(不是强制要求,但作为规范建议使用)
​	**驼峰命名法,**首字母小写,每个单词的开头字母大写,其余字母小写
​		例如:helloWorld

​	JS底层保存标识符时实际上时采用的的unicode编码,
​		所以理论上讲,所有的utf-8中含有的内容都可以作为标识符使用

### 数据类型

​	数据类型指的就是字面量的类型
​	在js中一共有六种数据类型
​		String 字符串
​		Number 数值
​		Boolean 布尔值
​		Null 空值
​		Undefined 未定义
​		Object 对象

​	其中String Number Boolean Null Undifined 属于基本数据类型
​		而Object属于引用数据类型

#### String 字符串

​	在js中字符串需要使用引号引起来
​	使用双引号或单引号都可以,但不能混着用
​	引号不能嵌套,双引号内不能放双引号，单引号内不能放单引号 引号不能换行

​	在字符串中我们可以使用\作为转移字符，
​	当表示一些特殊符号时可以使用\进行转义
​		`\"`  表示 "
​		`\'`  表示 '
​		`\n`  表示空格
​		`\t`  制表符(TAB)
​		`\\`  表示 \ (自己转义自己)
​		`<br />`表示换行
​	输出字面量 字符串str
​		`alert("str")`
​	输出变量str 变量值是多少就输出多少
​		`alert(str)`

#### Number

​	在js中所有数值都是number类型，包括整数和浮点数

​	js中可以表示的数字的最大值和最小值

```
Number.MAX_VALUE
1.7976931348623157e+308

Number.MIN_VALUE 大于0的最小值（最小正值）
5e-324
```

​	如果使用number表示的数字超过了最大值，则会返回一个
​		`infinity`    表示正无穷
​		`-infinity`    表示负无穷
​		使用typeof检查infinity 也会返回number

​	NaN 是一个特殊的数字，表示Not A Number
​		使用typeof检查一个NaN也会返回number

​	数字123
​		`var a = 123;`
​	字符串123
​		`var b = "123";`

​	可以使用一个运算符typeof来检查一个变量的类型
​	语法：typof 变量
​		检查字符串时，会返回string
​		检查数值时，会返回number

```
console.log(typeof a);
```

​	在js中整数的运算基本可以保证精确
​	如果使用js进行浮点运算，可能会得到一个不精确的结果
​	所以千万不要使用js进行对精确度要求比较高的运算

#### Boolean

​	boolean 布尔值 
​	布尔值只有两个，主要用来做逻辑判断
​		true
​		表示真
​		false
​		表示假

​	使用typeof检查一个布尔值时，会返回boolean

#### Null和Undefined

​	Null类型的值只有一个，就是null
​	null这个值专门用来表示一个为空的对象
​		使用typeof检查一个null值时，会返回object

​	Undefined（未定义）类型的值只有一个，就是undefined
​	当声明一个变量，但是不给变量赋值时，它的值就是undefined
​		使用typeof检查一个undefined时也会返回undefined

### 强制数据类型转换

强制类型转换
指将一个数据类型强制转换为其他的数据类型
类型转换主要指，将其他的数据类型，转换为
String Number Boolean
            

#### 将其他的数据类型转换为String

方式一
	调用被转换数据类型的toString（）方法
	该方法不会影响到原变量，他会将转换的结果返回
		注意：这个方法不适用于null和undefined
	由于这两个类型的数据中没有toString()方法，所以调用toString()时会报错

方式二
	调用string()函数，并将被转换的数据作为参数传递给函数
	使用string()函数做强制类型转换时，对于Number和Boolean实际上就是调用的toString()方法
	但是对于Null和Undefined，就不会调用toString()方法
		它会将null 直接转换为字符串"null"
		将undefined 直接转换为字符串"undefined"
            

#### 将其他的数据类型转换为Number

方式一
	使用Number()函数(有所局限，稍微有不合法的都会转换为NaN)
	调用Number()函数来将a转换为Number类型
		a = Number(a);
	字符串 转 数字
		1.如果是纯数字的字符串，则直接将其转换为数字
		2.如果字符串中有非数字的内容，则转换为NaN
		3.如果字符串是一个空串或者是一个全是空格的字符串，则转换为0

​	布尔值 转 数字
​		True 转为 1
​		False 转为 0

​	Null 转 数字  结果为 0

​	Undefined 转 数字  结果为 NaN

方法二
	这种方式专门用来对付字符串
		parseInt() 把一个字符串转换为一个整数
		parseInt()可以将一个字符串中的有效的整数内容取出来，然后转换为Number
		parseFloat() 把一个字符串转换为一个浮点数
		parseFloat()作用和parseInt()类似，不同的是它可以获得有效的小数
	如果对非String使用以上俩，它会先将其转换为String，然后再操作


#### 将其他的数据类型转换为Boolean

使用Boolean()函数
	将其他的数据类型转换为Boolean
		数字 ---> 布尔
	除了0和NaN，其余的都是true

​		字符串 ---> 布尔
​	除了空串，其余的都是true

​	null和undefined都会转换为false

​	对象也会转换为true   

#### 其他的进制的数字(进制转换器)

​	在js中，如果需要表示16进制的数字，则需要以0x开头
​	如果需要表示八进制的数字，则需要以0开头
​	如果要表示二进制的数字，则需要以0b开头（用得比较少，不是所有浏览器都支持）

​	像"070"这种字符串，有些浏览器会当成八进制解析，有些会当成十进制解析
​	解决办法：在parseInt()中传递一个第二个参数，来指定数字的进制
​		`parseInt(a,10);`

#### *调用a的toString()方法

​	调用xxx 的yyy()方法就是xxx.yyy()

### 运算符

运算符也叫操作符
	通过运算符可以对一个或多个值进行运算,并获取运算结果,运算符不会对原变量产生影响
	比如：typeof就是运算符，可以来获得一个值的类型
	它会将该值的类型以字符串的形式返回
	number string boolean undefined object

#### 算数运算符

当对非Number类型的值进行运算时，会将这些值转换为Number然后再运算（！！除了字符串的加法）
	任何值和NaN做运算都得NaN（不是数字的都得NaN）
note:算数运算从左至右依次取2值进行计算，注意参与运算的元素的类型
+
	+可以对两个值进行加法运算，并将结果返回
	如果对两个字符串进行加法运算，则会做拼串
	拼串会将两个字符串拼接为一个字符串，并返回
	任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
		可以利用这一特点，来将一个任意的数据类型转换为String，只需为任意的数据类型 + 一个""即可
		这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用了String()函数
-
	-可以对两个值进行减法运算，并将结果返回

`*`
	`*` 可以对两个值进行乘法运算

`/`
	`/` 可以对两个值进行除法运算

`%`
`	%` 取模运算（取余数

任何值做`- * /`运算时都会自动转换为Number
	可以利用这一特点做隐式的类型转换
可以通过为一个值 -0 *1 /1 来将其转换为Number
	+0 不行 如果遇到字符串会产生拼串
	原理和Number()函数一样，使用起来更加简单（**但不是最终方式**）

#### 一元运算符

​	只需要一个操作数
​		`+` 正号
​	正号不会对数字产生任何影响
​		`-` 负号
​	负号可以对数字进行负号的取反

​	对于非Number类型的值，
​		它会将先转换为Number，然后在运算
​	可以对一个其他的数据类型使用+,来将其转换为number
​		它的原理和Number()函数一样

#### 自增和自减

自增 ++
	通过自增可以使变量在自身的基础上增加1
	对于一个变量自增以后，原变量的值会立即自增1（少数会影响原变量的符号）
自增分成两种：后++(a++) 和 前++(++a)	
	无论是a++ 还是 ++a，都会立即使原变量的值自增1
	不同的是a++ 和 ++a的值不同
	a++的值等于原变量的值（自增前的值）
	++a的值等于新值 （自增后的值）
		先++ 是先+1  然后再赋值，后++ 是先赋值再+1

自减 --
	通过自减可以使变量在自身的基础上减1
自减分成两种：后--(a--) 和 前--(--a)
	无论是a-- 还是 --a 都会立即使原变量的值自减1
	不同的是a-- 和 --a的值不同
	a-- 是变量的原值 （自减前的值）
	--a 是变量的新值 （自减后的值）
		先-- 是先-1  然后再赋值，后-- 是先赋值再-1

#### 逻辑运算符

JS中为我们提供了三种逻辑运算符
	`!` 非
	`!`可以用来对一个值进行非运算
		所谓非运算就是指对一个布尔值进行取反操作，
		true变false，false变true
	如果对一个值进行两次取反，它不会变化
	如果对非布尔值进行运算，则会将其转换为布尔值，然后再取反
	所以我们可以利用该特点，来将一个其他的数据类型转换为布尔值
	可以为一个任意数据类型取两次反，来将其转换为布尔值，
		var a = "hello";
		a = !!a;!@#$%^&*
	原理和Boolean()函数一样

​	`&&` 与
​	`&&`可以对符号两侧的值进行与运算并返回结果
​	运算规则
​		两个值中只要有一个值为false就返回false，
​		只有两个值都为true时，才会返回true
​	JS中的“与”属于短路的与，
​		如果第一个值为false，则不会检查第二个值

​	`||` 或
​	`||`可以对符号两侧的值进行或运算并返回结果
​	运算规则：
​		两个值中只要有一个true，就返回true
​		如果两个值都为false，才返回false
​	JS中的“或”属于短路的或
​		如果第一个值为true，则不会检查第二个值

​	`&& ||` 非布尔值的情况
​		对于非布尔值进行与或运算时，
​		会先将其转换为布尔值，然后再运算，并且返回原值（运算时是转化为布尔值进行运算）

​	与运算：
​		如果第一个值为true，则必然返回第二个值
​		如果第一个值为false，则直接返回第一个值
​			 
​	或运算:
​		如果第一个值为true，则直接返回第一个值
​		如果第一个值为false，则返回第二个值

**以上可以理解为：基于与和或的运算规则，在什么地方停住了，就返回哪个地方的值**

#### 赋值运算符

`=`
可以将符号右侧的值赋值给符号左侧的变量
`+=` 
`a += 5` 等价于 `a = a + 5`
`-=`
`a -= 5` 等价于 `a = a - 5`
`*=`
`a *= 5` 等价于` a = a * 5`
`/=`
`a /= 5` 等价于 `a = a / 5`
`%=`
`a %= 5` 等价于 `a = a % 5`

#### 关系运算符

通过关系运算符可以比较两个值之间的大小关系，
	如果关系成立它会返回true，如果关系不成立则返回false

`>` 大于号
	判断符号左侧的值是否大于右侧的值
	如果关系成立，返回true，如果关系不成立则返回false

`>=` 大于等于
	判断符号左侧的值是否大于或等于右侧的值

`<` 小于号
`<=` 小于等于

非数值的情况
	对于非数值进行比较时，会将其转换为数字然后再比较
	**任何值和NaN作任何比较都是false**
	如果符号两侧的值都是字符串时，不会将其转换为数字进行比较
		而会分别比较字符串中字符的Unicode编码
	比较字符编码时是一位一位进行比较，如果两位一样，则比较下一位
	所以可以借用它来对英文进行排序，比较中文时没有意义
	如果比较两个字符串型的数字，可能会得到不可预期的结果
	**注意：在比较两个字符串型的数字时，一定要转型**

#### 相等运算符

相等运算符用来比较两个值是否相等，
如果相等会返回true，否则返回false
			
使用 `==` 来做相等运算
	当使用==来比较两个值时，如果值的类型不同，
	则会自动进行类型转换，将其转换为相同的类型，然后再比较
	大部分情况会转换成数字
	**特殊情况：  null == 0  会返回false**
	undefined衍生自null，所以这两个值做相等判断时，会返回true
NaN不和任何值相等，包括它本身（做相等运算返回的都是false）

##### 	*如何判断一个值是否是NaN:

​		通过`isNaN()`函数来判断一个值是否是NaN，如果该值是NaN，则返回true

不相等
	不相等用来判断两个值是否不相等，如果不相等返回true，否则返回false
	使用 `!=` 来做不相等运算
	不相等也会对变量进行自动的类型转换，如果转换后相等它也会返回false

`===`
全等
	用来判断两个值是否全等，它和相等类似，不同的是它不会做自动的类型转换
	如果两个值的类型不同，直接返回false

`!==`
不全等
	用来判断两个值是否不全等，和不等类似，不同的是它不会做自动的类型转换
	如果两个值的类型不同，直接返回true

#### 条件运算符

条件运算符也叫三元运算符
	语法：
		条件表达式?语句1:语句2;
	执行的流程：
	条件运算符在执行时，首先对条件表达式进行求值，
		如果该值为true，则执行语句1，并返回执行结果
		如果该值为false，则执行语句2，并返回执行结果
	如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算
	获取a和b中的最大值
		var max = a > b ? a : b;

#### `,`运算符

使用`,`可以分割多个语句，一般可以在声明多个变量时使用,

使用`,`运算符同时声明多个变量
	`var a , b , c;`

可以同时声明多个变量并赋值
	`var a=1 , b=2 , c=3;`
	`alert(b);`

#### 运算符优先级

就和数学中一样，在JS中运算符也有优先级，
	比如：先乘除 后加减
在JS中有一个运算符优先级的表，
	在表中越靠上优先级越高，优先级越高越优先计算，
	如果优先级一样，则从左往右计算。

<img src="C:\Users\阿堆\Desktop\study\typora\img\微信图片_20210406160237.png" style="zoom: 50%;" />

但是这个表我们并不需要记忆，如果遇到优先级不清楚
	可以使用()来改变优先级

```
var result = (1 + 2) * 3;
var result = 1 + (2 * 3);
```

如果||的优先级高，或者两个一样高，则应该返回3
如果与的优先级高，则应该返回1

### 代码块

我们的程序是由一条一条语句构成的
	语句是按照自上向下的顺序一条一条执行的
在JS中可以使用{}来为语句进行分组，同一个{}中的语句我们称为是一组语句，它们要么都执行，要么都不执行，一个{}中的语句我们也称为叫一个代码块
	代码块后边不用再编写;了

JS中的代码块，只具有分组的的作用，没有其他的用途
	代码块内部的内容，在外部是完全可见的，不是隔离在内部的

#### 流程控制语句

JS中的程序是从上到下一行一行执行的
	通过流程控制语句可以控制程序执行流程，
	使程序可以根据一定的条件来选择执行
语句的分类：
	1.条件判断语句
	2.条件分支语句
	3.循环语句

##### 条件判断语句

使用条件判断语句可以在执行某个语句之前进行判断，
如果条件成立才会执行语句，条件不成立则语句不执行。

if语句
	语法一：
	if(条件表达式){
	语句...
	}

if语句在执行时，会先对条件表达式进行求值判断，
	如果条件表达式的值为true，则执行if后的语句，
	如果条件表达式的值为false，则不会执行if后的语句。
if语句只能控制紧随其后的那个语句，如果希望if语句可以控制多条语句，可以将这些语句统一放到代码块中
**if语句后的代码块不是必须的，但是在开发中尽量写上代码块，即使if后只有一条语句**

​	语法二:
​	if(条件表达式){
​	语句...
​	}else{
​	语句...
​	}

if...else...语句
当该语句执行时，会先对if后的条件表达式进行求值判断，
	如果该值为true，则执行if后的语句
	如果该值为false，则执行else后的语句

​	语法三：
​	if(条件表达式){
​	语句...
​	}else if(条件表达式){
​	语句...
​	}else if(条件表达式){
​	语句...
​	}else{
​	语句...
​	}

if...else if...else
当该语句执行时，会从上到下依次对条件表达式进行求值判断
	如果值为true，则执行当前语句。
	如果值为false，则继续向下判断。
如果所有的条件都不满足，则执行最后一个else后的语句
该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句

##### 条件分支语句
条件分支语句也叫switch语句
语法：
	switch(条件表达式){
	case 表达式:
	语句...
	break;
	case 表达式:
	语句...
	break;
	default:
	语句...
	break;
	}

执行流程：
	switch...case..语句
	在执行时会依次将case后的表达式的值和switch后的条件表达式的值进行全等比较，
		如果比较结果为true，则从当前case处开始执行代码。
		当前case后的所有的代码都会执行，我们可以在case的后边跟着一个break关键字，
			这样可以确保只会执行当前case后的语句，而不会执行其他的case
		如果比较结果为false，则继续向下比较
		如果所有的比较结果都为false，则只执行default后的语句

switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能，
	同样使用if也可以实现switch的功能，所以我们使用时，可以根据自己的习惯和具体需求来选择。

##### 循环语句

创建一个循环，往往需要三个步骤			
	1.初始化一个变量
	2.在循环中设置一个条件表达式
	3.定义一个更新表达式，每次更新初始化变量

循环语句：
	通过循环语句可以反复的执行一段代码多次

###### while循环

​	语法：
​	while(条件表达式){
​	语句...
​	}

while语句在执行时，先对条件表达式进行求值判断，如果值为true，则执行循环体，
循环体执行完毕以后，继续对表达式进行判断
	如果值为true，则继续执行循环体，以此类推
	如果值为false，则终止循环
			
do...while循环
	语法：
	do{
	语句...
	}while(条件表达式)
			
执行流程：
	do...while语句在执行时，会先执行循环体，循环体执行完毕以后，在对while后的条件表达式进行判断，如果结果为true，则继续执行循环体，执行完毕继续判断以此类推
	如果结果为false，则终止循环
			
	实际上这两个语句功能类似，不同的是while是先判断后执行，
	而do...while会先执行后判断，
		do...while可以保证循环体至少执行一次，
		而while不能

###### for循环

for循环也是一个循环语句，称为for循环
	在for循环中，为我们提供了专门的位置用来放三个表达式：
	1.初始化表达式
	2.条件表达式
	3.更新表达式

for循环的语法：
	for(①初始化表达式;②条件表达式;④更新表达式){
	③语句...
	}

for循环的执行流程：
	①执行初始化表达式，初始化变量（初始化表达式只会执行一次）
	②执行条件表达式，判断是否执行循环。
	如果为true，则执行循环③
	如果为false，终止循环
	④执行更新表达式，更新表达式执行完毕，继续重复②

for循环中的三个部分都可以省略，也可以写在外部
	如果在for循环中不写任何的表达式，只写两个;
	此时循环是一个死循环，会一直执行下去，慎用

```
	//死循环
	for(;;){
	alert("hello");
	}
```

###### 嵌套的for循环

见练习

#### break和continue

​	break关键字可以用来退出switch或循环语句
​	**不能在if语句中使用break和continue**
​	break关键字会立即终止离它最近的那个循环语句

```
        for(var i=0 ; i<5 ; i++){
			console.log(i);
				
			if(i == 2){
                //这里是终止了for循环
				break;
		    }
				
		}

        for(var i=0 ; i<5 ; i++){
			console.log("@外层循环"+i)
			for(var j=0 ; j<5; j++){
				break;
				console.log("内层循环:"+j);
			}
		}
```

​	可以为循环语句创建一个label，来标识当前的循环
​		label:循环语句
​	使用break语句时，可以在break后跟着一个label，
​	这样break将会结束指定的循环，而不是最近的


```
	    outer:
		for(var i=0 ; i<5 ; i++){
			console.log("@外层循环"+i)
			for(var j=0 ; j<5; j++){
				break outer;
				console.log("内层循环:"+j);
			}
		}
```

​	continue关键字可以用来跳过当次循环
​	同样continue也是默认只会对离他最近的循环起作用
​	continue一样可以在后面跟着一个label，用来跳过指定的当次循环


```
	    for(var i=0 ; i<5 ; i++){
			10
			if(i==2){
				continue;
			}
			
			console.log(i);
		}

	    outer:
			for(var i=0 ; i<5 ; i++){
				
				for(var j=0 ; j<5 ; j++){
					
					continue;
					
					console.log("-->"+j);
					
				}
				
				console.log("@--->"+i);
			}
```

#### 编码

在字符串中使用转义字符输入Unicode编码
\u四位编码

```
console.log("\u2620");
```

在网页中使用Unicode编码
&#编码; 这里的编码需要的是10进制

```
<h1 style="font-size: 200px;">&#9760;</h1>
<h1 style="font-size: 200px;">&#9856;</h1>
```

### 对象

JS中数据类型
	String 字符串
	Number 数值
	Boolean 布尔值
	Null 空值
	Undefined 未定义
以上这五种类型属于基本数据类型，以后我们看到的值只要不是上边的5种，全都是对象
	Object 对象

基本数据类型都是单一的值 比如："hello" 123 true,
	值和值之间没有任何的联系

在JS中来表示一个人的信息（name gender age）：
	var name = "孙悟空";
	var gender = "男";
	var age = 18;
如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体。

对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。

#### 对象的分类

​	1.内建对象
​		由ES标准中定义的对象，在任何的ES的实现中都可以使用
​		比如：Math String Number Boolean Function Object....

​	2.宿主对象
​		由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
​		比如 BOM（浏览器对象模型） DOM（文档对象模型）（这都是一组一组的对象）

​	3.自定义对象
​		由开发人员自己创建的对象

#### 创建对象

​	使用new关键字调用的函数，是构造函数constructor
​	构造函数是专门用来创建对象的函数
​	使用typeof检查一个对象时，会返回object

`var obj = new Object();`

#### 属性

在对象中保存的值称为属性
	向对象添加属性
	语法：对象.属性名 = 属性值;

```
//向obj中添加一个name属性
obj.name = "孙悟空";
//向obj中添加一个gender属性
obj.gender = "男";
//向obj中添加一个age属性
obj.age = 18;
```

读取对象中的属性
	语法：对象.属性名

如果读取对象中没有的属性，不会报错，而是会返回undefined
```
console.log(obj);
console.log(obj.gender);
console.log(obj.hello);
```

修改对象的属性值
	语法：对象.属性名 = 新值

```
obj.name = "tom";
```

删除对象的属性
	语法：delete 对象.属性名
删除对象属性之后再读取，会返回undefined

```
delete obj.name;

console.log(obj.age);
```

##### 属性名

向对象中添加属性
	属性名：
	对象的属性名不强制要求遵守标识符的规范
	什么乱七八糟的名字都可以使用
	但是我们使用时还是尽量按照标识符的规范去做

```
obj.name = "孙悟空";

obj.var = "hello";
```

如果要使用特殊的属性名，不能采用.的方式来操作
	需要使用另一种方式：
		语法：对象["属性名"] = 属性值
	读取时也需要采用这种方式
（实际上属性名就是一个字符串）

使用[]这种形式去操作属性，更加的灵活，
	在[]中可以直接传递一个变量，这样变量值是多少就会读取哪个属性
	而.的那种形式就直接把属性名写死了

```
obj["123"] = 789;
obj["nihao"] = "你好";
var n = "nihao";
//console.log(obj["123"]);
```

##### 属性值

​	JS对象的属性值，可以是任意的数据类型
​	甚至也可以是一个对象

```
obj.test = true;
obj.test = null;
obj.test = undefined;

//创建一个对象
var obj2 = new Object();
obj2.name = "猪八戒";

//将obj2设置为obj的属性
obj.test = obj2;
```

**in 运算符**
	通过该运算符可以检查一个对象中是否含有指定的属性
	如果有则返回true，没有则返回false
		语法：
		"属性名" in 对象

```
//检查obj中是否含有test2属性
console.log("test2" in obj);
console.log("test" in obj);
console.log("name" in obj);
```

#### 基本数据类型和引用数据类型

基本数据类型
	String Number Boolean Null Undefined			
引用数据类型
	Object

JS中的变量都是保存到栈内存中的，
	基本数据类型的值直接在栈内存中存储，
	值与值之间是独立存在的，修改一个变量不会影响其他的变量

对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，
	而变量保存的是对象的内存地址（对象的引用），如果两个变量保存的是同一个对象引用，
	当一个通过一个变量修改属性时，另一个也会受到影响
	当一个将变量属性修改为null后，会断开连接

```
var a = 123;
var b = a;
a++;

console.log("a = "+a);
console.log("b = "+b);

var obj = new Object();
obj.name = "孙悟空";

var obj2 = obj;
```
修改obj的name属性
```
obj.name = "猪八戒";

console.log(obj.name);
console.log(obj2.name);

//设置obj2为null
obj2 = null;

var c = 10;
var d = 10;
//console.log(c == d);

var obj3 = new Object();
var obj4 = new Object();
obj3.name = "沙和尚";
obj4.name = "沙和尚";

console.log(obj3);
console.log(obj4);
```

当比较两个基本数据类型的值时，就是比较值
	而比较两个引用数据类型时，它是比较的对象的内存地址，
	如果两个对象是一模一样的，但是地址不同，它也会返回false

```
console.log(obj3 == obj4);
```

#### 对象字面量

创建一个对象
`var obj = new Object();`
使用对象字面量来创建一个对象
`var obj = {};`
等同于
`var obj = new Object();`

使用对象字面量，可以在创建对象时，直接指定对象中的属性
	语法：{属性名:属性值,属性名:属性值....}
	对象字面量的属性名可以加引号也可以不加，建议不加,
	但是如果要使用一些特殊的名字，则必须加引号

属性名和属性值是一组一组的名值对结构，
	名和值之间使用 `:` 连接，多个名值对之间使用 `,` 隔开
	如果一个属性之后没有其他的属性了，就不要写 `,`

```
var obj2 = {

name:"猪八戒",
age:13,
gender:"男",
test:{name:"沙僧"}

};

console.log(obj2.test);
```

### 函数

函数 function
	函数也是一个对象，具有所有对象有的功能，但是比普通对象更加强大
	函数中可以封装一些功能（代码），在需要时可以执行这些功能（代码）
	函数中可以保存一些代码，在需要的时候调用
	使用typeof检查一个函数对象时，会返回function

我们在实际开发中几乎不使用构造函数来创建一个函数对象
	创建一个函数对象
	可以将要封装的代码以字符串的形式传递给构造函数
		`var fun = new Function("console.log('Hello 这是我的第一个函数');");`

封装到函数中的代码不会立即执行
	函数中的代码会在函数调用的时候执行
	调用函数
	语法：函数对象()
	当调用函数时，函数中封装的代码会按照顺序执行，调用几次就执行几次
	函数就很方便使用与修改
		`fun();`

使用 函数声明 来创建一个函数
语法：
	function 函数名([形参1,形参2...形参N]){
	语句...
	}

```
function fun2(){
	console.log("这是我的第二个函数~~~");
	alert("哈哈哈哈哈");
	document.write("~~~~(>_<)~~~~");
}

console.log(fun2);
//调用fun2
fun2();
```

使用 函数表达式 来创建一个函数 （匿名函数）
语法：
	var 函数名  = function([形参1,形参2...形参N]){
	语句....
	}

```
var fun3 = function(){
	console.log("我是匿名函数中封装的代码");
};

fun3();
```

#### 函数的参数

定义一个用来求两个数和的函数
	可以在函数的()中来指定一个或多个形参（形式参数）
	多个形参之间使用 , 隔开，声明形参就相当于在函数内部声明了对应的变量
	但是并不赋值

```
function sum(a,b){
	console.log("a = "+a);
	console.log("b = "+b);
	console.log(a+b);
}
```

在调用函数时，可以在()中指定实参（实际参数）
	实参将会赋值给函数中对应的形参

调用函数时解析器不会检查实参的类型,
	所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查
函数的实参可以是任意的数据类型

调用函数时，解析器也不会检查实参的数量
	多余实参不会被赋值
	如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined

#### 返回值

创建一个函数，用来计算三个数的和

​	可以使用 return 来设置函数的返回值
​	语法：
​	return 值

return后的值将会会作为函数的执行结果返回，
	可以定义一个变量，来接收该结果

​	在函数中return后的语句都不会执行

​	如果return语句后不跟任何值就相当于返回一个undefined，
​	如果函数中不写return，则也会返回undefined

return后可以跟任意类型的值

​	alert()函数没有返回值

```
function sum(a , b , c){
//alert(a + b +c);
var d = a + b + c;		
return d;	
//return undefined;		
}

//调用函数
//变量result的值就是函数的执行结果
//函数返回什么result的值就是什么
var result = sum(4,7,8);
//var result = alert("hello");
console.log("result = "+result);
```

定义一个函数，判断一个数字是否是偶数，如果是返回true，否则返回false
```
function isOu(num){

return num % 2 == 0;
}

var result = isOu(15);
```

定义一个函数，可以根据半径计算一个圆的面积，并返回计算结果
```
function mianji(r){
return 3.14*r*r;
}

result = mianji(5);
console.log("result = "+result);
```

创建一个函数，可以在控制台中输出一个人的信息
	可以输出人的 name age gender address

实参可以是任意的数据类型，也可以是一个对象
	当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递

```
function sayHello(o){
console.log("我是"+o.name+",今年我"+o.age+"岁了,"+"我是一个"+o.gender+"人"+",我住在"+o.address);
}

//创建一个对象
var obj = {
name:"孙悟空",
age:18,
address:"花果山",
gender:"男"

};

sayHello(obj);
```

实参可以是一个对象，也可以是一个函数
```
function fun(a){
console.log("a = "+a);
//a(obj);
}

//fun(sayHello);

//fun(function(){alert("hello")});

fun(mianji(10));
```

`mianji()`
	调用函数
	相当于使用的函数的返回值

`mianji`
	函数对象
	相当于直接使用函数对象

#### 立即执行函数

用括号将一个函数括起来，标识它为一个整体，在它之后再加一对括号，则会直接执行，后面那对括号可以为函数传递参数
	函数定义完，立即被调用，这种函数叫做立即执行函数
	立即执行函数往往只会执行一次

```
(function(a,b){
console.log("a = "+a);
console.log("b = "+b);
})(123,456);
```

#### this

解析器在调用函数时每次都会向函数内部传递进一个隐含的参数
这个隐含的参数就是this，this指向的是一个对象，这个对象我们称为函数执行的上下文对象，
	根据函数的调用方式不同，this会指向不同的对象
	1.以函数的形式调用时，this永远都是window
	2.以方法的形式调用时，this就是调用方法的对象
	3.以构造函数形式调用时，this就是构造函数新建的那个对象，同时this，proto 属性指向原型对象

### 对象与函数

对象的属性值可以是任何的数据类型，也可以是个函数
	函数也可以称为对象的属性，
	当一个函数作为一个对象的属性保存，那么我们称这个函数是这个对象的方法
	调用函数称为调用对象的方法(method)

但是它们只是名称上的区别，没有其他的区别

```
obj.sayName = function(){
console.log(obj.name); 
}

function fun(){
console.log(obj.name); 
}

//这个称为调方法
obj.sayName();
//这个称为调函数
fun();

//只是名称区分，没有本质差别
```

#### 枚举对象中的属性

使用for ... in 语句
	语法:
	`for(var 变量 in 对象){`
	`}`

for ... in 语句 对象中有几个属性，循环体就会执行几次
	每次执行时，会将对象中的一个属性的名字赋值给变量
	如果直接使用obj.n，这样找的就是名字和变量值一样的属性
	可以用中括号将变量括起来，obj[n]，这样找的就是被属性名字赋值过的变量，会返回属性值

```
for(var n in obj){
console.log(obj[n]);
}
```

#### 声明提前

##### 变量的声明提前

使用var关键字声明的变量，会在所有的代码执行之前被声明（但是不会赋值），
但是，如果声明变量时不使用var关键字，则变量不会被声明提前

##### 函数的声明提前

使用函数声明形式创建的函数 function 函数(){}
它会在所有的代码执行之前就被创建，所以我们可以在函数声明之前来调用函数
使用函数表达式创建的函数，不会被声明提前，所以不能在声明前调用

#### 作用域

作用域指一个变量的作用范围
在JS中  一共有两种作用域：

##### 1.全局作用域

​	直接编写在script标签中的JS代码，都在全局作用域
​	全局作用域在页面打开时创建，在页面关闭时销毁
​	在全局作用域中有一个全局对象window，
​		它代表的是一个浏览器的窗口，它由浏览器创建，我们可以直接使用
​	在全局作用域中，
​		创建的变量都会作为window对象的属性保存
​		创建的函数都会作为window对象的方法保存
​	全局作用域中的变量都是全局变量，
​		在页面的任意的部分都可以访问到

##### 2.函数作用域

​	调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
​	~~每调用一次函数就会创建一个新的函数作用域~~，作用域在函数定义时就已经确定了，而不是在调用时，他们之间是互相独立的
​	在函数作用域中，可以访问到全局作用域的变量，
​		在全局作用域中无法访问到函数作用域的变量
​	当在函数作用域中操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找
​		但上一级作用域不一定是全局作用域，可能上一级是嵌套自己的函数的作用域，如果一直找不到则会报错

​	在函数中要访问全局变量可以使用window对象（window.xx）

​	在函数作用域中也有声明提前的特性，使用var关键字声明的变量会在函数中所有代码执行之前被声明
​	函数声明也会在函数中所有代码执行之前执行

​	在函数中不使用var关键字声明的变量都会成为全局变量

​	定义形参就相当于在函数作用域中var关键字声明了变量

#### 创建对象的方法

##### 使用工厂方法创建对象

​	通过该方法可以大批量地创建对象
​	使用工厂方法创建的对象 使用的构造函数都是Object
​		就导致我们无法区分出多种不同类型的对象

```
function createPerson(name , age , gender){
//创建一个新的对象
var obj = new Object();

//向对象中添加属性
obj.name = name;
obj.age = age;
obj.gender = gender;
obj.sayName = function(){
alert(this.name);
}
//将新的对象返回
return obj;
}

var obj2 = createPerson("孙悟空",18,"男");
var obj3 = createPerson("猪八戒",28,"男");
var obj4 = createPerson("沙和尚",38,"男");

console.log(obj2);
console.log(obj3);
console.log(obj4);
```

##### 构造函数创建对象

​	创建一构造函数 专门用来创建Person对象的
​	构造函数就是一个普通的函数，创建方式和普通函数没有区别，
​	不同的是构造函数习惯上首字母大写
​		构造函数和普通函数的区别就是调用方式的不同

**普通函数是直接调用，而构造函数需要使用new关键字来调用**

构造函数执行流程：
	1.当调用构造函数的时候，立刻创建一个新的对象
	2.将新建的对象设置为函数中的this，在构造函数中可以使用this 来引用新的对象
	（当函数以构造函数的形式调用的时候，this就是新创建的对象）
	3.逐行执行函数中的代码
	4.将新创建的对象作为返回值返回

​	new person()会在堆中开辟一块区域，这片区域保存Person函数的内容，这块区域的地址赋值给 per

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类，
	我们将通过一个构造函数创建的对象，称为是该类的实例
	使用instanceof 可以检查一个对象是否是一个类的实例
	语法：
		`对象 instanceof 构造函数`
	如果是，则返回true， 否则返回false
	所有的对象都是Object的后代，所以任何对象和Object做instanceof检查时都会返回true

this的情况，
	1.当以函数的形式调用时，this是window
	2.当以方法的形式调用时，谁调用方法this就是谁
	3.当以构造函数的形式调用时，this就是新创建的那个对象

```
//创建一个 Person 的构造函数
function Person(name , age , gender){
this.name = name;
this.age = age;
this.gender = gender;
//this.sayName = function(){
//	alert(this.name);
//}
this.sayName = fun;
}
//调用构造函数
var per = new Person("孙悟空",18,"男");
var per2 = new Person("猪八戒",28,"男");
var per3 = new Person("沙和尚",38,"男");

console.log(per);
console.log(per2);
console.log(per3);
```

在Person构造函数中，为每一个对象都添加了一个sayName方法，
	目前我们的方法是在构建函数内部创建的，也就是构造函数每执行一次就会创建一个新的sayName方法
	也就是所有实例的sayName都是唯一的，这样就导致了构造函数执行一次就会创建一个新的方法，这是完全没有必要的，完全可以使所有的对象共享同一个方法

操作方法：
将sayName方法在全局作用域中定义
构造函数中的
`this.sayName = function(){`
	`alert(this.name);`
`}`
改为
`this.sayName = fun;`

```
function fun(){
alert(this.name);
};
```

### 原型

将函数定义在全局作用域中，污染了全局作用域的命名空间（它用了这个名字，别的就用不了了）
而且关键是定义在全局作用域中也很不安全（多人开发时容易起重名）
因此该方法具有局限性

#### 原型对象

​	原型prototype

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
	这个属性对应着一个对象，这个对象就是我们所谓的原型对象
如果函数作为普通函数调用，prototype没有任何作用
当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，
	指向该构造函数的原型对象，我们可以通过__protp__来访问该属性

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，
	我们可以将对象中共有的内容，统一设置到原型对象中

当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，
	如果没有，则会去原型对象中寻找，如果找到则直接使用

以后我们创建构造函数时，可以将这些对象共有的属性和方法统一添加到构造函数的原型对象中，
	这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了

```
//向MyClass的原型中添加属性a
MyClass.prototype.a = 123;
			
//向MyClass的原型中添加一个方法
MyClass.prototype.sayHello = function(){
alert("hello");
};
			
var mc = new MyClass();
	
var mc2 = new MyClass();
			
//console.log(MyClass.prototype);
//console.log(mc2.__proto__ == MyClass.prototype);
			
//向mc中添加a属性
mc.a = "我是mc中的a";
			
//console.log(mc2.a);
			
mc.sayHello();
```

#### toString

当我们直接在页面中打印一个对象时，实际上是输出的对象的toString()方法的返回值
如果我们希望在输出对象时不输出[object object]，可以为对象添加一个toString()方法

```
function Person(name , age , gender){
this.name = name;
this.age = age;
this.gender = gender;
}

//创建一个Person实例
var per = new Person("孙悟空",18,"男");
//修改Person原型的toString
Person.prototype.toString = function(){
return "Person[name="+this.name+",age="+this.age+",gender="+this.gender+"]";
};

console.log(per);        
```

#### 垃圾回收

垃圾回收（GC）
就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾
	这些垃圾积攒过多以后，会导致程序运行的速度过慢，
	所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾
当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，
	此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，
	所以这种垃圾必须进行清理。
在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，
	我们不需要也不能进行垃圾回收的操作
我们需要做的只是要将不再使用的对象设置null即可

### 数组

对象分为：
	内建对象
	宿主对象
	自定义对象

#### 数组（Array）

​	数组也是一个对象
​	不同的是普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引操作元素

#### 索引

​	从0开始的整数就是索引
数组的存储性能比普通对象要好，在开发中我们经常使用数组来存储一些数据

```
//创建数值对象
var arr = new Array();

//使用typeof检查一个数组时，会返回object
console.log(typeof arr);
```

**向数组中添加元素**
	语法：
	数组[索引] = 值

```
arr[0] = 10;
arr[1] = 20;
arr[2] = 30;
```

**读取数组中的元素**
	语法：
	数组[索引]
如果读取不存在的索引，不会报错而是返回undefined

```
console.log(arr[0]);
```

**获取数组的长度（元素的个数）**
	语法：
	数组.length
对于连续的数组，使用length可以获取到数组的长度（元素的个数）
对于非连续的数组，使用length会获取到最大的索引数+1
	尽量不要创建非连续的数组

```
console.log(arr.length);
```

**修改length**
	如果修改的length大于原长度，则多出部分会空出来
	如果修改的length小于原长度，则多出的元素会被删除（可以通过修改length来删除一些元素）

```
arr.length = 10;
console.log(arr.length);
```

通过length可以向数组的最后一个位置添加元素

```
arr[arr.length] = 40;
```

#### 创建数组

使用字面量来创建数组
	语法：[]
	var arr = [];

使用字面量创建数组时，可以在创建时就指定数组中的元素
```
var arr = [1,2,3,4,5,10];
```
使用构造函数创建数组时，也可以同时添加元素，将要添加的元素作为构造函数的参数传递，
	元素之间用 , 隔开
	但是构造函数很少用，一般都用字面量创建

```
var arr2 = new Array(10,20,30);
```
创建一个长度为10的数组
```
arr3 = new  Array(10);
```
数组中的额元素可以是任意的数据类型，也可以是对象，也可以是一个函数

数组中也可以放数组，如下这种数组我们称为二维数组
```
arr = [[1,2,3],[4,5,6],[7,8,9]];
```

### 数组的方法

四个常用方法：

`push()`

​	该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度
​	可以将要添加的元素作为方法的参数传递
​	这样这些元素将会自动添加到数组的末尾
​	该方法会将数组新的长度作为返回值返回

`arr.push("tang","zhi","bai");`

`pop()`

​	该方法可以删除数组的最后一个元素，调用一次就删除一次
​	并将被删除的元素作为返回值返回
​	（可以视为：弹出）
`arr.pop();`

`unshift()`

​	向数组开头添加一个或多个元素，并返回新的数组长度
​	向前边插入元素以后，其他的元素索引会依次调整
`arr.unshift("niu","er");`

`shift()`

​	该方法可以删除数组的第一个元素，并将被删除的元素作为返回值返回
​	（和pop相反）
`arr.shift();`

#### 遍历数组

所谓的遍历数组，就是将数组中所有的元素都取出来

```
for(var i=0 ; i<arr.length ; i++){
console.log(arr[i]);
}
```

一般我们都是使用for循环去遍历数组，
JS中还为我们提供了一个方法，用来遍历数组

`forEach()`

​	但是这个方法只支持IE8以上的浏览器，IE8及以下的浏览器均不支持
​	所以如果需要追求兼容性，则不要使用forEach，还是使用for循环比较稳妥

这个方法需要一个函数作为参考
	像这种由我们创建但是不由我们调用的，我们称为回调函数
	数组中有几个元素，函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参，来读取这些内容
	浏览器会在回调函数中传递三个参数，
		第一个参数：就是当前正在遍历的元素
		第二个参数：就是当前正在遍历的元素的索引
		第三个参数：就是正在遍历的数组
		（形参的名字无所谓）

```
arr.forEach(function(a , b , c){
console.log();
});
```

`slice()`

​	可以用来从数组中提取指定元素
​	该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回
​	参数：
​		1.截取开始的位置的索引，包含开始索引
​		2.截取结束的位置的索引，不包含结束索引
​	第二个参数可以省略不写，此时会截取从开始索引往后的所有元素

​	索引可以传递一个负值，如果传递一个负值，则从后往前计算
​		例：
​			-1 倒数第一个
​			-2 倒数第二个

```
var result = arr.slice(1,4);

console.log("result = "+ result);
```

`splice()`

​	可以用于删除数组中的指定元素
​	使用splice()会影响到原数组，会将指定元素从原数组中删除
​		并将被删除的元素作为返回值返回
​	参数：
​		第一个，表示开始位置的索引
​		第二个，表示删除的数量
​		第三个及以后，可以传递一些新的元素，这些元素将会自动插入到开始位置索引的前面
​		（可以利用这个特性删除、替换、插入元素）

```
var result = arr.splice(1,2,"niu");

console.log("result = "+ result);
```

`concat()`

​	该方法可以连接两个或多个数组，并将新的数组返回
​	该方法不会对原数组产生影响

```
        var result = arr.concat(arr2,arr3,"牛魔王","铁扇公主");
        document.write(result)
```

`join()`

​	该方法可以将数组转换为一个字符串
​	该方法不会对原数组产生影响
​	在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符
​		如果不指定连接符，则默认使用 , 作为连接符
​		如果不想有任何连接符，可以指定一个空串 ""

```
        result = arr.join("@@");
```

`reverse()`

​	该方法可以用来反转数组（前后互换）
​	该方法会对原数组产生影响，会直接修改原数组

```
        arr.reverse();
```

`sort()`

​	该方法可以用来对数组中的元素进行排序，默认会按照Unicode编码进行排序
​	该方法会对原数组产生影响

​	即使对于纯数字的数组，使用sort()排序时，也会按照Unicode编码来排序，所以对数字进行排序时，可能会得到错误的结果

​	我们可以自己来指定排序的规则
​		我们可以在sort()中添加一个回调函数，来指定排序规则
​		回调函数中需要定义两个形参，(a,b);
​		浏览器将会分别使用数组中的元素作为实参去调用回调函数
​		使用哪个元素调用不确定，但是肯定的是数组中a一定在b前面
​	浏览器会根据回调函数的返回值来决定元素的顺序，
​		如果返回一个小于0的值，则元素会交换位置
​		如果返回一个大于0的值，则元素位置不变
​		如果返回一个0，则认为两个元素相等
​		（不同浏览器可能不一样）

```
        arr = [5,4];

        //让元素从小到大排序
        arr.sort(function(a,b){
            //前边的大
            if(a > b){
                return -1;
            //前边的小
            }else if(a < b){

                return 1;
            //相等
            }else{
                return 0;
            }
            /*
            //或者这样写

            //升序
            return b - a;
            //降序
            return a - b;
            */
        });
```

### 函数的方法
`call()和apply()`

​	这两个方法都是函数对象的方法，需要通过函数对象来调用
​	当对函数调用call()和apply()都会调用函数执行
​	在调用call()和apply()时可以将一个对象指定为第一个参数
​		此时这个对象将会成为函数执行时的this（也就是可以手动更改this指向）
​	call()方法可以将实参在对象之后依次传递
​	apply()方法需要将实参封装到一个数组中（[]）统一传递

​	**this的情况，**
​		1.当以函数的形式调用时，this是window
​		2.当以方法的形式调用时，this是调用方法的对象
​		3.当以构造函数的形式调用时，this就是新创建的那个对象
​		4.使用call和apply调用时，this是指定的那个对象

```
        fun.call(obj,2,3);
        fun.apply(obj,[2,3]);

        var obj = {
            name:"obj",
            sayName:function(){
                alert(this.name);
            }
        };

        var obj2 = {
            name:"obj2"
        }
        
        /*fun.apply();
        fun.call();
        fun();*/
        //以上仨使用效果都一样
```

`arguments`

在调用函数时，浏览器每次都会传递进两个隐含的参数
	1.函数的上下文对象this
	2.封装实参的对象arguments
		arguments是一个类数组对象（不是数组对象），它既可以通过索引来操作数组，也可以获取长度
		在调用函数时，我们所传递的实参都会在arguments中保存
		arguments.length可以用来获取实参的长度（传递了几个实参就是几）
		我们即使不定义形参，也可以通过arguments来使用实参
只不过比较麻烦
		arguments[0] 表示第一个实参
		arguments[1] 表示第二个实参
		以此类推……
	arguments中有一个属性叫callee
		这个属性对应一个函数对象，就是当前正在指向的函数对象

#### Date对象

在JS中使用Date对象来表示一个时间

如果直接使用构造函数创建一个Date对象，则会封装为当前代码执行的时间

```
var d = new Date();
```

创建一个指定的时间对象
	需要在构造函数中传递一个表示时间的字符串作为参数
	日期的格式 "月份/日/年 时:分:秒" 最好都写完整，避免歧义

```
var d2 = new Date("2/28/2021 05:20:00");
```

`getDate()`
	获取当前日期对象是几日
`getDay()`
	获取当前日期对象是周几
	会返回一个0-6的值
		0表示周日
		1表示周一
		……23456
`getMonth()`
	获取当前日期对象的月份
	会返回一个0-11的值
		0表示一月
		1表示二月
		2表示三月
		……
		11表示十二月
	可以+1表示当前月份
`getFullYear()`
	获取当前日期对象的完整年份
`getHours()`
	获取当前日期对象的时
`getMinutes()`
	获取当前日期对象的分
`getSeconds()`
	获取当前日期对象的秒
`getMilliseconds()`
	获取当前日期对象的毫秒

`getTime()`
	获取当前日期对象的时间戳
	时间戳，指的是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）
	计算机底层在保存时间时使用的都是时间戳
`time = Date.now()`
	获取当前的时间戳

​	可以利用时间戳来测试代码的执行性能

```
var date = d.getDate();
var day = d.getDay();
var day = d.getMonth();
var day = d.getFullYear();
var day = d.getHours();
var day = d.getMinutes();
var day = d.getSeconds();
var day = d.getMilliseconds();

var time = d.getTime();

//获取当前的时间戳
time = Date.now();
```

### Math

Math和其他的对象不同，它不是一个构造函数
	它属于一个工具类，不用创建对象，里边封装了数学运算相关的属性和方法
比如
	`Math.PI` 表示圆周率
	`Math.E` 表示自然指数
	（一般大写的都表示一个常量）

​	`Math.abs()` 用来计算一个数的绝对值
​	`Math.ceil()` 可以对一个数进行向上的取整，小数位只要有值就自动进1
​	`Math.floor()` 可以对一个数进行向下取整，小数部分会被舍掉
​	`Math.round()` 可以对一个数进行四舍五入取整
​	`Math.random()` 可以用来生成一个0-1之间的随机数
​		生成一个0-x之间的随机数

```
Math.round(Math.random()*x)
```
​		生成一个x-y之间的随机数
```
Math.round(Math.random()*(y-x)+x)
```
​	（以上实际上不是完全随机）

​	`Math.max()` 可以获取多个数中的最大值
​	`Math.min()` 可以获取多个数中的最小值

​	`Math.pow(x,y)` 可以返回x的y次幂
​	`Math.sqrt(x)` 用于对一个数x进行开方运算

```
//生成100个0-10的随机数
        for(var i=0 ; i<100 ; i++){
            document.write(Math.round(Math.random()*10) + "\n");
        }
```

### 包装类

基本数据类型
	String Number Boolean Null Undefined
引用数据类型
	Object

在JS中为我们提供了三个包装类，通过这三个包装类可以将基本数据类型的数据转换为对象
	`String()`
		可以将基本数据类型字符串转换为String对象
	`Number()`
		可以将基本数据类型的数字转换为Number对象
	`Boolean()`
		可以将基本数据类型的布尔值转换为Boolean对象
	但是注意，在实际应用中不会使用基本数据类型的对象
		如果使用基本数据类型的对象，在进行比较的时候，可能会出现不可预期的结果

方法和属性只能添加给对象，不能添加给基本数据类型
	当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将其转换为对象，然后再调用对象的属性和方法

```
var str = new String("hello");
var num = new Number(3);
var bool = new Boolean(true);
```

### 字符串的方法

在底层字符串是以字符数组的形式保存的
["H","e","l","l","o"]
对数组可以进行的操作也可以用在字符串上
比如：
length属性
	可以用来获取字符串的长度

字符串的相关方法

`charAt()`

​	可以返回字符串中指定位置的字符
​	根据索引获取指定的字符

`charCodeAt()`

​	获取指定位置字符的字符编码（Unicode编码）

`fromCharCode()`

​	可以根据字符编码去获取字符（和charCodeAt()相反）

`concat()`

​	可以用来连接两个或多个字符串，作用和 + 一样

`indexOf()`

​	该方法可以检索一个字符串中是否含有指定内容
​	如果字符串中含有该内容，则会返回其第一次出现的索引
​		如果字符串中不含有，则返回-1
​	可以指定一个第二个参数，指定开始查找的位置

`lastIndexOf()`

该方法的用法和indexOf()一样
	不同的是indexOf是从前往后找
	而lastIndexOf是从后往前找
也可以指定开始查找的位置

`slice()`

​	可以从字符串中截取指定的内容
​	不会影响原字符串，而是将截取到的内容返回
​	参数：
​		第一个，开始位置的索引（包括开始位置）
​		第二个，结束位置的索引（不包括结束位置）
​			如果省略第二个参数，则会截取到后边所有的
​		也可以传递一个负数作为参数，负数阿德话将会从后边开始计算

`substring()`

​	可以用来截取一个字符串，不会影响原字符串，和slice()类似
​	参数：
​		第一个，开始截取位置的索引（包括开始位置）
​		第二个，结束位置的索引（不包括结束位置）
​	不同的是这个方法不能接受负值作参数
​		如果传递一个负值，则默认使用0
​	而且他还自动调整参数的位置，如果第二个参数小于第一个，则自动交换

`substr()`

​	用来截取字符串，不会影响原字符串
​	参数：
​		第一个，截取开始位置的索引
​		第二个，截取的长度

`split()`

​	（很常见）
​	可以将一个字符串拆分为一个数组
​	参数：
​		需要一个字符串作为参数，将会根据该字符串去拆分数组（以该字符串为分界点来拆分出数组内的元素）
​		如果传递一个空串作为参数，则会将每一个字符都拆分为数组中的一个元素

`toLowerCase()`

​	将字符串转换为小写并返回

`toUpperCase()`

​	将字符串转换为大写并返回

### 正则表达式

​	正则表达式用于定义一些字符串的规则
​		计算机可以根据正则表达式，来检查一个字符串是否符合规则
​		或者将字符串中符合规则的内容提取出来

创建正则表达式的对象
	语法：
	var 变量 = new RegExp("正则表达式","匹配模式");
	使用typeof检查正则对象，会返回object
```
var reg = new RegExp("a");
```
​	这个正则表达式可以用来检查一个字符串中是否含有a
在构造函数中可以传递一个匹配模式作为第二个参数
​	可以是
​		i 忽略大小写
​		g 全局匹配模式
​	var reg = new RegExp("a","i");

### 正则表达式的方法

#### test()

使用这个方法可以用来检查一个字符串是否符合正则表达式的规则
严格区分大小写
	如果符合则返回true，否则返回false

```
var reg = new RegExp("a","i");

var str = "a";

var result = reg.test(str);

console.log(result);
console.log
```

#### 使用字面量来创建正则表达式

​	语法：var 变量 = /正则表达式/匹配模式
使用字面量的方式创建更加简单
使用构造函数创建更加灵活

使用 | 表示或者的意思（可以检查一个字符串中有没有其中一个）
[]里的内容也是或的关系
	[ab] == a|b
`[a-z]` 任意小写字母
`[A-Z]` 任意大写字母
`[A-Za-z]` 任意字母
`[0-9]` 任意数字
也可以这样写：a[bde]c 表示检查有无abc、adc、aec
`[^ ]` 除了

```
var reg = /a/i;
reg = /a|b/;
reg = /[A-Za-z]/;
reg = /a[bde]c/;
reg = /[^ab]/;
```

### 字符串与正则表达式

`split()`

​	可以将一个字符串拆分为一个数组、
​	方法中可以传递一个正则表达式作为参数，这样方法将会根据正则表达式去拆分字符串
​	这个方法即使不指定全局匹配，也会全都拆分（默认全局匹配）
如：
​	根据任意字母来将字符串拆分
```
str.split(/[A-Za-z]/);
```
`search()`

​	可以搜索字符串中是否含有指定内容
​	如果搜索到指定内容，则会返回第一次出现的索引，如果没有则返回-1
​	它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串
​	search()只会查找第一个，即使设置全局匹配也没用

```
var result = str.split(/[A-Za-z]/);
```
`match()`

​	可以根据正则表达式，从一个字符串中将符合条件的内容提取出来
​	默认情况下match()只会找到第一个符合要求的内容，找到后就停止检索
​		可以设置正则表达式为全局匹配模式。这样就会匹配到所有的内容
​		可以为一个正则表达式设置多个匹配模式，且没有顺序要求
​	match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果

`replace()`

​	可以将字符串中指定内容替换为新的内容，不会影响原字符串
​	参数：
​		1.被替换的内容
​		2.新的内容
​	默认只会替换第一个
​	可以使用空串来替换，起到删除的效果

```
result = str.match(/[A-Za-z]/ig);

result = str.replace("a" , "@");
```

### 正则表达式的语法

#### 量词

通过量词可以设置一个内容出现的次数
量词只对它前边的一个内容起作用
找到了就会返回true，就不会再找下面的了
`{n}` 正好出现n次
`{m,n}` 出现m-n次
`{m, }` m次以上
`+` 至少一个，相当于{1, }
`*` 0个或多个，相当于{0, }
`?` 0个或1个，相当于{0,1}
`^` 表示开头 `/^a/`
`$` 表示结尾 `/a$/`
	可以这样写 `/^a$/`
	如果在正则表达式中同时使用^ $则要求字符串必须完全符合正则表达式
	也可以这样写 `/^a|a$/`
	这样就表示以a开头，或者以a结尾

创建一个正则表达式，用来检查一个字符串是否是一个合法手机号
手机号的规则
	1.以1开头
	2.第二位3-9任意数字
	3.三位以后任意数字9个

​	`^1  [3-9]  [0-9]{9}$`
```
var phoneStr = "13123456789";
var phoneReg = /^1[3-9][0-9]{9}$/;

console.log(phoneReg.test(phoneStr));
```

`.` 表示任意字符

检查一个字符串中是否含有 `.`

在正则表达式中可以使用\作为转义字符
`\.` 表示 `.`
`\\` 表示 `\`
字符串中表示`\`也需要写作`\\`

**注意:使用构造函数时，由于它的参数是一个字符串，而\是字符串中的转义字符，如果要使用\则需要使用\\来代替**

```
var reg = /\./;
reg = /\\/;
reg = new RegExp("\\.");
```
`\w`  任意字母，数字，下划线_ `[A-Za-z0-9_]`
`\W`  除了字母，数字，下划线_ `[^A-Za-z0-9_]`
`\d`  任意的数字 `[0-9]`
`\D`  除了数字 `[^0-9]`
`\s`  空格
`\S`  除了空格
`\b`  单词边界
	单词边界，一个单词前后的空格（是不是单独单词）
`\B`  除了单词边界

去除掉字符串中前后的空格
	去除空格就是使用""来替换空格，不过要记得加上`^`和`$`，以及全局匹配`g`

```
str = str.replace(/^\s*|\s*$/g,"");
```

#### *电子邮件的正则表达式

电子邮件
任意字母数字下划线 ，任意字母数字下划线 @ 任意字母数字 .任意字母（2-5位） .任意字母（2-5位）

`\w{3,}  (\.\w+)* @ [A-Za-z0-9]+ (\.[A-z]{2,5}){1,2}`

```
var emailReg = /^\w{3,}(\.\w+)*@[A-Za-z0-9]+(\.[A-z]{2,5}){1,2}$/;
var email = "abc.abc@163.com";
console.log(emailReg.test(email));
```

### DOM

Document Object Model
文档对象模型
JS中通过DOM来对HTML文档进行操作。只要理解了DOM就可以随心所欲地操作WEB页面。
文档
	文档表示的就是整个的HTML网页文档
对象
	对象表示将网页中的每一个部分都转换为了一个对象
	（转换为对象后，就可以以纯面向对象的方式来操纵一个网页）
模型
	使用模型来表示对象之间的关系，这样方便我们获取对象

#### 节点

节点Node，是构成我们网页的最基本的组成部分，网页中的每一个部分都可以成为是一个节点
	比如：html标签、属性、文本、注释、整个文档等都是一个节点、
	虽然都是节点，但是实际上他们的具体类型是不同的
比如：标签我们称为元素节点、属性称为属性节点、文本称为文本节点、文档称为文档节点
节点的类型不同，属性和方法也都不尽相同
	文档节点：整个HTML文档
	元素节点：HTML文档中的标签
	属性节点：元素的属性
	文本节点：HTML标签中的文本内容

浏览器已经为我们提供了 **文档节点** 对象，这个对象是window属性
可以在页面中直接使用，文档节点代表的是整个网页

##### 节点的属性

![](C:\Users\阿堆\Desktop\study\typora\img\微信图片_20210420164227.png)

#### 事件

事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间
	JavaScript与HTML之间的交互是通过事件实现的
	对于Web应用来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方、按下键盘上某个键，等等。就是用户和浏览器之间的交互行为。

我们可以在事件对应的属性中设置一些js代码
	这样当事件被触发时，这些代码将会执行
	这种写法称为结构和行为耦合，不方便维护，不推荐使用

可以为按钮的对应事件绑定处理函数的形式来响应事件
（推荐方式）

```
    <button id="btn">按钮</button>
    <script>
        var btn = document.getElementById("btn");

        btn.onclick = function(){
            alert("好玩吗？");
        };
    </script>
```

#### 文档的加载

浏览器在加载一个页面时，是按照自上向下的顺序加载的
读取到一行就运行一行，如果将script标签写到页面的上边
	在代码执行时，页面还没有加载，DOM对象也没有加载
	会导致无法获取到DOM对象
将js代码编写到页面的下部就是为了可以在页面加载完毕以后再执行js代码

`onload`
onload事件会在整个页面加载完成之后才触发
	为window绑定一个onload事件
	该事件对应的响应函数将会在页面加载完成之后执行
这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了

```
	window.onload = function () {

		var btn = document.getElementById("btn");

		btn.onclick = function () {
			alert("hello");
		}
	};
```

#### DOM查询

##### 获取元素节点

​	通过document对象调用

`getElmentById()`
	通过*id属性*获取一个元素节点对象
`getElmentsByTagName()`
	通过*标签名*获取一组元素节点对象
`getElmentsByName()`
	通过*name属性*获取一组元素节点对象

如果需要读取元素节点属性，
	直接使用 元素.属性名
	例子：元素.id 元素.name 元素.value
	*注意：唯独class属性不能采用这种方式，*
	读取class属性时需要使用 元素.className

##### 获取元素节点的子节点

​	通过具体的元素节点调用
1.`getElementsByTagName()`
​	方法，返回当前节点的指定标签名后代节点
2.`childNodes`
​	属性，表示当前节点的所有子节点
3.`firstChild`
​	属性，表示当前节点的第一个子节点
4.`lastChild`
​	属性，表示当前节点的最后一个子节点

##### 获取父节点和兄弟节点

​	通过具体的节点调用
1.`parentNode`
​	属性，表示当前节点的父节点
2.`previousSibling`
​	属性，表示当前节点的前一个兄弟节点
3.`nextSibling`
​	属性，表示当前节点的后一个兄弟节点

##### DOM查询的方法

`previousElementSibling`
该属性可以获取前一个兄弟元素，IE8及以下不支持

`getElementsByTagName()`
可以根据标签名来获取一组元素节点对象
这个方法会给我们返回一个类数组对象，所有查询到的元素都会封装到这个对象中
即使查询到的元素只有一个，也会封装到数组中返回

`childNodes`
会获取包括文本节点在内的所有节点
根据DOM标准，文本间的空白也会当成文本节点
注意，在IE8及以下的浏览器中，不会将空白文本当成子节点

`children`
可以获取当前元素的所有子元素

`firstChild`
可以获取到当前元素的第一个子节点（包括空白文本节点）

`firstElementChild`
可以获取到当前元素的第一个子元素（但兼容度不高 ie8及以下不支持）

`innerHTML`
用于获取元素内部的HTML代码的
对于自结束标签，这个属性没有意义

`innerText`
该属性可以获取到元素内部的文本内容
它和innerHTML类似，不同的是，它会自动将html标签去除

`document.body`
获取body标签
在document中有一个属性body，它保存的是body的引用

`document.documentElement`
保存的是html根标签

`document.all`
代表页面中所有的元素

```
var all = document.all;
console.log(all.length);
//等同于↓
all = document.getElementsByTagName("*");
```

根据元素的class属性值查询一组元素节点对象
`getElementsByClassName()`可以根据class属性值获取一组元素节点对象
但这个方法存在兼容性问题（不支持IE8及以下浏览器）

```
var box1 = document.getElementsByClassName("box1");
```

获取一个class下的所有同标签
比如：.box1 div

`document.querySelector()`
需要一个选择器的字符串作为参数，可以根据一个CSS选择器来查询一个元素节点对象（很强大）
虽然IE8中没有getElementsByClassName()，但是可以使用querySelector()代替
使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回第一个元素

`document.querySelectorAll()`
该方法和document.querySelector()使用方法类似
不同的是它会将所有
符合条件的元素封装到一个数组中返回
即使符合条件的元素只有一个，它也会返回数组

#### DOM增删改

`document.createElement()`
可以用于创建一个元素节点对象，
	它需要一个标签名作为参数，将会根据该标签名创建元素节点对象
	并将创建好的对象作为返回值返回

`createTextNode()`
可以用来创建一个文本节点对象
	它需要一个文本内容作为参数，将会根据该内容创建文本节点
	并将新的节点返回

`appendChild()`
向一个父节点中添加一个新的子节点
	语法：父节点.appendChild（子节点）

`insertBefore()`
可以在指定的子节点前插入新的子节点
	语法：
	父节点.insertBefore(新节点,旧节点);

`replaceChild()`
可以使用指定的子节点替换已有的子节点
	语法：父节点.replaceChild(新节点 , 旧节点);

`removeChild()`
可以删除一个子节点
	语法：父节点.removeChild(子节点);

也可以利用`parentNode`来获取父节点，进行删除，这样更加方便也更常用
	语法：子节点.parentNode.removeChild(子节点);

使用`innerHTML`也可以完成DOM的增删改的相关操作
	一般我们会两种方式结合使用（推荐使用）

```
//向city中添加广州
//city.innerHTML += "<li>广州</li>"
                
//创建一个li
var li = document.createElement("li");
//向li中设置文本
li.innerHTML = "广州";
//将li添加到city中
city.appendChild(li);
```

##### a的索引问题

for循环会在页面加载完成之后立即执行
而响应函数会在超链接被点击时才执行
当响应函数执行时，for循环早已执行完毕

#### 使用DOM操作CSS

##### 通过JS修改元素的样式

语法：
元素.style.样式名 = 样式值

注意：如果CSS的样式名中含有 `-` ，
	这种名称在JS中是不合法的，比如background-color
	需要将这种样式名修改为驼峰命名法
	去掉 - ，将 - 后的字母大写

通过style属性设置的样式都是内联样式，
而内联样式存在较高的优先级，所以通过JS修改的样式往往会立即显示

但是如果在样式中写了 `!important` ,则此时样式会有最高的优先级
	即使通过JS也不能覆盖该样式，此时将会导致JS修改样式失效
	所以尽量不要为样式添加 !important

```
box1.style.width = "250px";
box1.style.backgroundColor = "red";
```

##### 读取元素的样式

语法
元素.style.样式名
	但这个有局限性，只能读取内联样式

##### 获取元素当前显示的样式

语法
元素.currentStyle.样式名
	它可以用来读取当前元素正在显示的样式
	如果当前元素没有设置样式，则获取它的默认值
但是这个只有ie浏览器支持，其他浏览器都不支持

在其他浏览器中可以使用
	`getComputedStyle()`这个方法来获取元素当前的样式
	这个方法是window的方法，可以直接使用
需要两个参数
	第一个，要获取的样式的元素
	第二个，可以传递一个伪元素，一般都传null
该方法会返回一个对象，对象中封装了当前元素对应的样式
需要用 对象.样式名 的方式来获取样式，比较麻烦一点
	如果获取的样式没有设置，则会获取到真实的值，而不是默认值
	比如：没有设置width，它不会获取到auto，而是一个长度
但是该方法不支持IE8以下的浏览器

通过currentStyle和getComputedStyle()读取到的样式都是只读的
	不能修改，如果要修改必须通过style属性

```
/*
定义一个函数，用来获取指定元素的当前的样式
参数：
obj 要获取样式的元素
name 要获取的样式名
*/

function getStyle(obj , name){

	if(window.getComputedStyle){
	//正常浏览器的方式，具有getComputedStyle()方法
	return getComputedStyle(obj , null)[name];
	}else{
	//IE8的方式，没有getComputedStyle()方法
	return obj.currentStyle[name];
}
				
//return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];

}

// alert(box1.style.width);
// alert(box1.style.backgroundColor)
// alert(box1.currentStyle.width);

//alert("width = " + (getComputedStyle(box1,null)).width);

var w = getStyle(box1 , "width");

alert(w);
```

由于兼容性的问题，没有一个方法可以兼容浏览器来获取元素样式，所以需要写一个函数
定义一个函数，用来获取指定元素的当前的样式
参数
	obj 要获取样式的元素
	name 要获取的样式名

```
function getStyle(obj , name){
//因为getComputedStyle是全局的一个属性，所以可以在getComputedStyle前加一个window，这样就变成了一个变量的属性，
//如果在浏览器中没找到会返回undefined，否则会去全局中找，没找到就会报错，不会执行下一步
if(window.getComputedStyle){
return getComputedStyle(obj , null)[name];
}else{
return obj.currentStyle[name];
}

//以上这段代码等同于↓ 但推荐上面那个 结构更加清晰
//return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];

//正常浏览器的方式
//return getComputedStyle(obj , null)[name];

//IE8的方式
//return obj.currentStyle[name];
}
```

##### 其他样式操作的相关属性

`clientWidth`
`clientHeight`
	这两个属性可以获取元素的可见宽度和高度
	这些属性都是不带px的，返回都是一个数字，可以直接进行计算
	会获取元素宽度和高度，包括内容区和内边距，不包括边框
	这些属性都是只读的，不能修改

```
alert(box1.clientWidth);
alert(box1.clientHeight);
box1.clientHeight = 300;
```

`offsetWidth`
`offsetHeight`
	获取元素的整个的宽度和高度，和client类似，不过它包括内容区、内边距和边框

```
alert(box1.offsetWidth);
```

`offsetParent`
	可以用来获取当前元素的定位父元素
	会获取到离当前元素最近的开启了定位的祖先元素
		如果所有的祖先元素都没有开启定位，则返回body

```
var op = box1.offsetParent;
```

`offsetLeft`
	当前元素相对于其定位父元素的水平偏移量
`offsetTop`
	当前元素相对于其定位父元素的垂直偏移量

```
alert(box1.offsetLeft);
```

`scrollWidth`
`scrollHeight`
	可以获取元素整个滚动区域的宽度和高度

```
alert(box4.scrollWidth);
```

`scrollLeft`
	可以获取水平滚动条滚动的距离
`scrollTop`
	可以获取垂直滚动条滚动的距离

```
alert(box4.scrollLeft);
alert(box4.scrollTop);
```

当满足`scrollHeight - scrollTop == clientHeight`
说明垂直滚动条滚动到底了
					
当满足`scrollWidth - scrollLeft == clientWidth`
说明水平滚动条滚动到底

```
alert(box4.scrollHeight - box4.scrollTop); 
```

当垂直滚动条滚动到底时使表单项可用
`onscroll`
该事件会在元素的滚动条滚动时触发 

### 事件对象

当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数
在事件对象中封装了当前事件相关的一切信息，比如，鼠标的坐标 键盘哪个按键被按下 鼠标滚轮滚动的方向

在IE8中，响应函数被触发时，浏览器不会传递事件对象
在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的
所以想要在IE8浏览器运行，需要在事件对象前加一个 window.

也可能在别的浏览器出现兼容性问题，这里就可以做一个判断，如果没有event，则令event = window.event
```
if(!event){
event = window.event;
}
```

或者这样写↓

```
event = event || window.event;
```

clientX 可以获取鼠标指针的水平坐标
clientY 可以获取鼠标指针的垂直坐标

```
var x = event.clientX;
var y = event.clientY;
```
#### 事件的冒泡

​	所谓的冒泡指的就是及事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发
​	在开发中，大部分情况冒泡都是有用的，如果不希望发生事件冒泡，可以通过事件对象来取消冒泡

取消冒泡
	可以将事件对象的canselBubble设置为true，即可取消冒泡
`event.cancelBubble = true;`

#### 事件的委派

​	我们为每一个超链接都绑定一个单击响应函数，这种操作比较麻烦
​	而且这些操作只能为已有的超链接设置事件，而新添加的超链接必须重新绑定、
​	我们希望只绑定一次事件，即可应用到多个元素上，即使元素是后添加的
​	我们可以尝试将其绑定给元素的共同的祖先元素

​	事件的委派指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件，
​	事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能

#### 事件的绑定

使用 对象.事件 = 函数 的形式绑定响应函数
	它只能同时为一个元素的一个事件绑定一个响应函数
	不能绑定多个，如果绑定了多个，则后边会覆盖掉前边的

```
btn01.onclick = function(){
alert(1);
}

btn01.onclick = function(){
alert(2);
}
```

`addEventListener()`
	通过这个方法也可以为元素绑定响应函数
	参数
		1.事件的字符串，不要on
		2.回调函数，当事件触发时该函数会被调用
		3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false

使用addEventListener()可以同时为一个元素的相同事件同时绑定多个响应函数，
	这样当事件被触发时，响应函数将会按照函数的绑定顺序执行

*这个方法不支持IE8及以下的浏览器*
`attachEvent()`
	在IE8中可以使用attachEvent()来绑定事件
	参数
		1.事件的字符串，要on
		2.回调函数
这个方法也可以同时为一个事件绑定多个处理函数
	不同的是它是后绑定先执行，执行顺序和addEventListener()相反

```
btn01.addEventListener("click",function(){
alert(1);
},false);

bind(btn01 , "click" , function(){
alert(this);
});
```
定义一个函数，用来为指定元素绑定响应函数

addEventListener()中的this，是绑定事件的对象
attachEvent()中的this，是window
需要统一两个方法this

​	参数：
​		obj 要绑定事件的对象
​		eventStr 事件的字符串(不要on)
​		callback 回调函数

```
function bind(obj , eventStr , callback){
				if(obj.addEventListener){
					//大部分浏览器兼容的方式
					obj.addEventListener(eventStr , callback , false);
				}else{
					/*
					this是谁由调用方式决定
					callback.call(obj)
					*/
					//IE8及以下
					obj.attachEvent("on"+eventStr , function(){
						//在匿名函数中调用回调函数
						callback.call(obj);
					});
				}
            }
```
#### 事件的传播

​	关于事件的传播 网景公司和微软公司有不同的理解
​	微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，然后再向当前元素的祖先元素上传播，也就是说事件应该在冒泡阶段执行
​	网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，然后再向内传播给后代元素
​	W3C综合了两个公司的方案，将事件的传播分成了三个阶段
​		1.捕获阶段
​			在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件
​		2.目标阶段
​			事件捕获到了目标元素，捕获结束，开始在目标元素上触发事件
​		3.冒泡阶段
​			事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件

​		如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true
​			一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false

*IE8及以下的浏览器中没有捕获阶段*

```
		function bind(obj , eventStr , callback){
			if(obj.addEventListener){
				//大部分浏览器兼容的方式
				obj.addEventListener(eventStr , callback , true);
			}else{
				/*
				this是谁由调用方式决定
				callback.call(obj)
				*/
				//IE8及以下
				obj.attachEvent("on"+eventStr , function(){
					//在匿名函数中调用回调函数
					callback.call(obj);
				});
			}
        }
```

`setCapture()`
	当调用一个元素的setCapture()方法以后，这个元素将会把下一次所有的鼠标按下相关的事件捕获到自身上
`releaseCapture()`
	取消setCapture()方法

*只有IE支持，但是在火狐中调用时不会报错*
*而如果使用chrome调用，会报错*

​	当我们去拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容
​	此时会导致拖拽功能的异常，这个是浏览器提供的默认行为
​	如果不希望发生这个行为，则可以通过return false来取消默认行为

#### 滚轮的事件

`onwheel`
`onmousewheel`
鼠标滚轮滚动的事件，会在滚轮滚动时触发
	IE只支持onmousewheel

在火狐中需要使用 DOMMouseScroll 来绑定滚动事件
	注意该事件需要通过addEventListener()函数来绑定

**判断鼠标滚轮滚动的方向**

`event.wheelDelte` 可以获取鼠标滚轮滚动的方向
`wheelDelte`这个值不看大小，只看正负
	向上滚正值，向下滚负值

wheelDelte这个属性火狐中不支持
	在火狐中使用event.detail来获取滚动的方向
	向上滚-3 向下滚3

```
	if(event.wheelDelta > 0 || event.detail < 0){
	//向上滚，box1变短
	box1.style.height = box1.clientHeight - 10 + "px";
	}else{
	//向下滚，box1变长
	box1.style.height = box1.clientHeight + 10 + "px";
	}
```

使用addEventListener()方法绑定响应函数，取消默认行为时，不能使用return false
	需要使用event来取消默认行为 event.preventDefault();
	但是IE8不支持event.preventDefault(); 如果直接调用会报错

```
event.preventDefault() && event.preventDefault();
```

当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动
	*这是浏览器的默认行为，如果不希望发生，则可以取消默认行为(return false)*

#### 键盘的事件

`onkeydown`
按键被按下
	对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发
	当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快
	这种设计是为了防止误操作的发生。

`onkeyup`
	按键被松开

*键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document*

可以通过keyCode来获取按键的编码
	通过它可以判断哪个按键被按下
	除了keyCode，事件对象中还提供了几个属性
		`altKey`
		`ctrlKey`
		`shiftKey`
这三个属性用来判断alt ctrl 和 shift是否被按下
	如果按下则返回true，否则返回false

```
		//console.log(event.keyCode);
		//数字keycode为 48 - 57 小键盘区为 96 - 105
		//使文本框中不能输入数字
		if(event.keyCode >= 48 && event.keyCode <= 57 || event.keyCode >= 96 && event.keyCode <= 105){
			//在文本框中输入内容，属于onkeydown的默认行为
			//如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中
			return false;
		}
```

### BOM

浏览器对象模型
	BOM可以使我们通过JS来操作浏览器
	在BOM中为我们提供了一组对象，用来完成对浏览器的操作

#### BOM对象

`Window`
	代表的是整个浏览器的窗口，同时window也是网页中的全局对象
`Navigator`
	代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
`Location`
	代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面
`History`
	代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录
		由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页
		而且该操作只在当次访问时有效
`Screen`
	代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息

*这些BOM对象在浏览器中都是作为window对象的属性保存的，*
*可以通过window对象来使用，也可以直接使用*

#### Navigator对象

代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器
由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了
一般我们只会使用userAgent来判断浏览器的信息，
	userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，
	不同的浏览器会有不同的userAgent

在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了
如果通过UserAgent不能判断，还可以通过一些浏览器中特有的对象，来判断浏览器的信息
	比如：ActiveXObject

#### History对象

History对象可以用来操作浏览器向前或向后翻页

`length`
	属性，可以获取到当次访问的链接数量

`back()`
	可以用来回退到上一个页面，作用和浏览器的回退按钮一样

`forward()`
	可以跳转下一个页面，作用和浏览器的前进按钮一样

`go()`
	可以用来跳转到指定的页面
	它需要一个整数作为参数
		1:表示向前跳转一个页面 相当于forward()
		2:表示向前跳转两个页面
		-1:表示向后跳转一个页面
		-2:表示向后跳转两个页面

#### Location对象

该对象中封装了浏览器的地址栏的信息

如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）

如果直接将location属性修改为一个完整的路径，或相对路径
	则我们页面会自动跳转到该路径，并且会生成相应的历史记录

```
location = "http://www.baidu.com";
location = "01.BOM.html";
```

`assign()`
	用来跳转到其他的页面，作用和直接修改location一样

```
location.assign("http://www.baidu.com");
```

`reload()`
	用于重新加载当前页面，作用和刷新按钮一样
	如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面

```
location.reload(true);
```

`replace()`
	可以使用一个新的页面替换当前页面，调用完毕也会跳转页面
	不会生成历史记录，不能使用回退按钮回退

### 定时器

#### 定时调用

`setInterval()`
	可以将一个函数，每隔一段时间执行一次
	参数：
		1.回调函数，该函数会每隔一段时间被调用一次
		2.每次调用间隔的时间，单位是毫秒

​	返回值：
​		返回一个Number类型的数据
​		这个数字用来作为定时器的唯一标识

*在开启定时器之前，需要将当前元素上的其他定时器关闭*

`clearInterval()`
	可以用来关闭一个定时器
	方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
		clearInterval()可以接收任意参数
	如果参数是一个有效的定时器的标识，则停止对应的定时器
	如果参数不是一个有效的标识，则什么也不做

```
var num = 10;

var timer = setInterval(function(){

count.innerHTML = num--;

if(num == 0){
//关闭定时器
clearInterval(timer);
}

},1000);
```

#### 延时调用

`setTimeout()`

延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次
	延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次
	延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择

使用`clearTimeout()`来关闭一个延时调用

```
var timer = setTimeout(function(){
console.log(num++);
},3000);

clearTimeout(timer);
```

#### 定时器的应用

尝试创建一个可以执行简单动画的函数

​	参数：
​		obj:要执行动画的对象
​		attr:要执行动画的样式，比如：left top width height
​		target:执行动画的目标位置
​		speed:移动的速度(正数向右移动，负数向左移动)
​		callback:回调函数，这个函数将会在动画执行完毕以后执行

```
function move(obj, attr, target, speed, callback) {
	//关闭上一个定时器
	clearInterval(obj.timer);

	//获取元素目前的位置
	var current = parseInt(getStyle(obj, attr));

	//判断速度的正负值
	//如果从0 向 800移动，则speed为正
	//如果从800向0移动，则speed为负
	if(current > target) {
		//此时速度应为负值
		speed = -speed;
	}

	//开启一个定时器，用来执行动画效果
	//向执行动画的对象中添加一个timer属性，用来保存它自己的定时器的标识
	obj.timer = setInterval(function() {

		//获取box1的原来的left值
		var oldValue = parseInt(getStyle(obj, attr));

		//在旧值的基础上增加
		var newValue = oldValue + speed;

		//判断newValue是否大于800
		//从800 向 0移动
		//向左移动时，需要判断newValue是否小于target
		//向右移动时，需要判断newValue是否大于target
		if((speed < 0 && newValue < target) || (speed > 0 && newValue > target)) {
			newValue = target;
		}

		//将新值设置给box1
		obj.style[attr] = newValue + "px";

		//当元素移动到0px时，使其停止执行动画
		if(newValue == target) {
			//达到目标，关闭定时器
			clearInterval(obj.timer);
			//动画执行完毕，调用回调函数
			callback && callback();
		}

	}, 30);
}
```

定义一个函数，用来获取指定元素的当前的样式
	参数：
		obj 要获取样式的元素
		name 要获取的样式名

```
function getStyle(obj, name) {

	if(window.getComputedStyle) {
		//正常浏览器的方式，具有getComputedStyle()方法
		return getComputedStyle(obj, null)[name];
	} else {
		//IE8的方式，没有getComputedStyle()方法
		return obj.currentStyle[name];
	}

}
```

*可以定义一个全局变量timer，用来保存定时器的标识*
*所有的执行正在执行的定时器都在这个变量中保存*

### 类的操作
通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面
这样的执行的性能是比较差的，而且当我们要修改多个样式时，这种形式也不太方便
在开发中不建议使用这种方式来修改样式
```
box.style.width = "200px";
box.style.height = "200px";
box.style.backgroundColor = "yellow";
```
可以使用一行代码同时修改多个样式

我们可以通过修改元素的class属性来间接修改样式
这样一来，我们只需要修改一次，即可同时修改多个样式
	浏览器只需要重新渲染页面一次，性能比较好
	并且这种方式，可以使表现和行为进一步分离，不会出现耦合现象
使用+=可以使得样式不仅有“替换”，还可以做到“添加”    

```
box.className += " b2";
```

同时可以定义一些函数，可以通过对类进行操作实现一些功能

#### addClass(obj , cn)

定义一个函数，用来向一个元素中添加指定的class属性值
	参数：
		obj 要添加class属性的元素
		cn 要添加的class值

```
        function addClass(obj , cn){
            
            //检查obj中是否含有cn
            if(!hasClass(obj , cn)){
                obj.className += " "+cn;
            }
        }
```
#### hasClass(obj , cn)

判断一个元素中是否含有指定的class属性值
如果有则返回true，没有则返回false
	参数：
		obj 要判断的class属性的元素
		cn 要判断的class值

```
        function hasClass(obj , cn){
            
            //用正则表达式判断obj中有没有cn class
            // var reg = /\bb2\b/;
            var reg = new RegExp("\\b"+cn+"\\b");

            return reg.test(obj.className);
        }
```

#### removeClass(obj , cn)

​	删除一个元素中的指定class属性

```
        function removeClass(obj , cn){
            var reg = new RegExp("\\b"+cn+"\\b");

            //删除class
            obj.className = obj.className.replace(reg , "")
        }
```
#### toggleClass(obj , cn)

​	toggleClass可以用来切换一个类
​	如果元素中具有该类，则删除，如果元素中没有该类，则添加

```
        function toggleClass(obj , cn){
            //判断obj中是否含有cn，有则删除，无则添加
            if(hasClass(obj , cn)){
                removeClass(obj , cn);
            }else{
                addClass(obj , cn);
            }
        }
```

### JSON

JS中的对象只有JS自己认识，其他的语言都不认识
JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别
	并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互

**JSON**
	*JavaScript Object Notation* JS对象表示法
	JSON和JS对象的格式一样，只不过JSON字符串中属性名必须加双引号
		其他的和JS语法一致（JSON是一种特殊的字符串）
	JSON分类：
		1.对象 {}
		2.数组 []

​	JSON中允许的值：
​		1.字符串
​		2.数值
​		3.布尔值
​		4.null
​		5.对象
​		6.数组

```
	//创建一个对象
	var obj = '{"name":"sunwukong","age":18,"gender":"男"}';

	var arr = '[1,2,3,"hello",true]'

	var obj2 = '{"arr":[1,2,3]}'

	var arr2 = '[{"name":"sunwukong","age":18,"gender":"男"},{"name":"sunwukong","age":18,"gender":"男"}]'
```

#### 将JSON字符串转换为JS中的对象

​	在JS中，为我们提供了一个工具类，就叫JSON
​	这个对象可以帮助我们将一个JSON转换为JS对象，也可以将一个JS对象转换为JSON

**JSON --> JS对象**

`JSON.parse()`
	可以将一个JSON字符串转换为js对象
	它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回

**JS对象 --> JSON**

`JSON.stringify()`
	可以将一个JS对象转换为JSON字符串
	需要一个JS对象作为参数，会返回一个JSON字符串

```
	var json = '{"name":"sunwukong","age":18,"gender":"男"}';

	var o = JSON.parse(json);

	var obj3 = {name:"zhubajie" , age:28 , gender:"男"};

	var str = JSON.stringify(obj3);
```

JSON这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错

如果需要兼容IE7及以下的JSON操作，则可以通过引入一个外部的js文件来处理

#### eval()

​	这个函数可以用来执行以daunt字符串形式的JS代码，并将执行结果返回
​	如果使用eval()执行的字符串中含有{}，它会将{}当成是代码块
​		如果不希望将其当成代码块解析，则需要在字符串前后各加一个()    

eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码
	但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患

```
	var str2 = '{"name":"sunwukong","age":18,"gender":"男"}';

	var str3 = "alert('hello');";

	var obj3 = eval("("+str3+")");
```